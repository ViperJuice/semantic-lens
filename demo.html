<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Semantic Lens - Graph Visualization</title>
  <script src="https://unpkg.com/cytoscape@3.28.1/dist/cytoscape.min.js"></script>
  <!-- fCoSE layout and its dependencies -->
  <script src="https://unpkg.com/layout-base@2.0.1/layout-base.js"></script>
  <script src="https://unpkg.com/cose-base@2.2.0/cose-base.js"></script>
  <script src="https://unpkg.com/cytoscape-fcose@2.2.0/cytoscape-fcose.js"></script>
  <script src="https://unpkg.com/webcola@3.4.0/WebCola/cola.min.js"></script>
  <script src="https://unpkg.com/cytoscape-cola@2.5.1/cytoscape-cola.js"></script>
  <style>
    * { box-sizing: border-box; }
    body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, sans-serif; background: #f8f9fa; color: #24292f; }

    #app { display: flex; height: 100vh; }

    /* Sidebar */
    #sidebar {
      width: 280px;
      background: #ffffff;
      border-right: 1px solid #d0d7de;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    #sidebar h2 {
      margin: 0;
      padding: 16px;
      font-size: 14px;
      font-weight: 600;
      border-bottom: 1px solid #d0d7de;
      color: #0969da;
    }

    .sidebar-section {
      padding: 12px 16px;
      border-bottom: 1px solid #d0d7de;
    }

    .sidebar-section h3 {
      margin: 0 0 8px 0;
      font-size: 12px;
      font-weight: 600;
      color: #57606a;
      text-transform: uppercase;
    }

    /* Controls */
    select, input, button {
      width: 100%;
      padding: 8px 12px;
      margin: 4px 0;
      font-size: 13px;
      border-radius: 6px;
      border: 1px solid #d0d7de;
      background: #ffffff;
      color: #24292f;
    }

    select:focus, input:focus { outline: none; border-color: #0969da; }

    button {
      background: #2da44e;
      border-color: #2da44e;
      color: #fff;
      cursor: pointer;
      font-weight: 500;
    }
    button:hover { background: #2c974b; }
    button.secondary { background: #f6f8fa; border-color: #d0d7de; color: #24292f; }
    button.secondary:hover { background: #f3f4f6; }

    /* Auto-fit toggle button */
    #autoFitToggle {
      background: #f6f8fa;
      border: 1px solid #d0d7de;
      color: #57606a;
    }
    #autoFitToggle.active {
      background: #dafbe1;
      border-color: #2da44e;
      color: #1a7f37;
    }
    #autoFitToggle:hover {
      background: #f3f4f6;
    }
    #autoFitToggle.active:hover {
      background: #aceebb;
    }

    /* Legend */
    .legend-item {
      display: flex;
      align-items: center;
      padding: 4px 0;
      font-size: 12px;
      cursor: pointer;
    }
    .legend-item:hover { color: #0969da; }
    .legend-item.disabled { opacity: 0.4; }
    .legend-dot {
      width: 12px;
      height: 12px;
      border-radius: 3px;
      margin-right: 8px;
    }
    .legend-count {
      margin-left: auto;
      color: #57606a;
      font-size: 11px;
    }

    /* File list */
    #fileList {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
    }
    .file-item {
      padding: 6px 8px;
      font-size: 12px;
      border-radius: 4px;
      cursor: pointer;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .file-item:hover { background: #f6f8fa; }
    .file-item.selected { background: #ddf4ff; color: #0969da; }

    /* Graph container */
    #main {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    #toolbar {
      padding: 8px 16px;
      background: #ffffff;
      border-bottom: 1px solid #d0d7de;
      display: flex;
      gap: 8px;
      align-items: center;
    }

    #toolbar button { width: auto; padding: 6px 12px; }
    #toolbar .spacer { flex: 1; }
    #stats { font-size: 12px; color: #57606a; }

    #cy { flex: 1; background-color: #1a1a2e; }

    /* Node info panel */
    #nodeInfo {
      position: absolute;
      bottom: 16px;
      right: 16px;
      width: 320px;
      background: #ffffff;
      border: 1px solid #d0d7de;
      border-radius: 8px;
      padding: 16px;
      display: none;
      box-shadow: 0 8px 24px rgba(0,0,0,0.15);
    }
    #nodeInfo.visible { display: block; }
    #nodeInfo h4 { margin: 0 0 8px 0; color: #0969da; font-size: 14px; }
    #nodeInfo .info-row {
      display: flex;
      font-size: 12px;
      padding: 4px 0;
      border-bottom: 1px solid #f0f0f0;
    }
    #nodeInfo .info-label { color: #57606a; width: 80px; }
    #nodeInfo .info-value { flex: 1; word-break: break-all; }
    #nodeInfo .signature {
      font-family: monospace;
      font-size: 11px;
      background: #f6f8fa;
      padding: 8px;
      border-radius: 4px;
      margin-top: 8px;
      overflow-x: auto;
    }

    /* Lens styles */
    .lens-fade {
      opacity: 0.12 !important;
    }
    #toolbar select {
      width: auto;
      padding: 6px 12px;
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="sidebar">
      <h2>Semantic Lens</h2>

      <div class="sidebar-section">
        <h3>View</h3>
        <select id="viewType">
          <option value="full">All Nodes</option>
          <option value="call_graph">Call Graph</option>
          <option value="inheritance">Inheritance</option>
          <option value="module_deps">Module Dependencies</option>
        </select>
        <select id="layoutType">
          <option value="community">Community (recommended)</option>
          <option value="elk">ELK (server-side)</option>
          <option value="hierarchy">Hierarchical (by file)</option>
          <option value="cola">Force-directed (cola)</option>
          <option value="grid">Grid</option>
          <option value="circle">Circle (by file)</option>
        </select>
      </div>

      <div class="sidebar-section">
        <h3>Data Source</h3>
        <select id="fixtureSelect">
          <option value="api">Live API</option>
          <option value="fixtures/semantic-lens-v4.slb" selected>semantic-lens-v4 (435 nodes)</option>
          <option value="fixtures/semantic-lens-v3.slb">semantic-lens-v3 (435 nodes)</option>
          <option value="fixtures/realistic-bundle.json">realistic-bundle (37 nodes)</option>
        </select>
      </div>

      <div class="sidebar-section">
        <h3>Search</h3>
        <input type="text" id="search" placeholder="Search nodes...">
      </div>

      <div class="sidebar-section">
        <h3>Level of Detail</h3>
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 13px;">
          <input type="checkbox" id="showMethods" style="width: auto; margin: 0;">
          <span>Show Methods</span>
        </label>
      </div>

      <div class="sidebar-section">
        <h3>Graph Display</h3>
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 13px; margin-bottom: 8px;">
          <input type="checkbox" id="showIsolateRing" checked style="width: auto; margin: 0;">
          <span>Show isolate ring</span>
        </label>
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 13px; margin-bottom: 8px;">
          <input type="checkbox" id="fitToConnected" checked style="width: auto; margin: 0;">
          <span>Fit to connected only</span>
        </label>
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 13px; margin-bottom: 8px;">
          <input type="checkbox" id="hideExternalEdges" style="width: auto; margin: 0;">
          <span>Hide external edges</span>
        </label>
        <div style="margin-top: 8px;">
          <label style="font-size: 12px; color: #8b949e; display: block; margin-bottom: 4px;">Edge Display</label>
          <select id="edgeMode" style="width: 100%;">
            <option value="all" selected>All Edges</option>
            <option value="hover">Hover Reveal</option>
            <option value="selection">Selection Only</option>
            <option value="off">Off</option>
          </select>
        </div>
        <div id="graphStats" style="margin-top: 10px; font-size: 12px; color: #8b949e;">
          Connected: <span id="connectedCount">0</span> | Isolates: <span id="isolateCount">0</span> (ring)
        </div>
      </div>

      <div class="sidebar-section">
        <h3>Edge Filtering</h3>
        <select id="edgeFilter">
          <option value="all">All Edges</option>
          <option value="non-synthetic">Non-Synthetic Only</option>
          <option value="structural">Structural Only (defines/inherits/implements)</option>
        </select>
      </div>

      <div class="sidebar-section">
        <h3>Node Types</h3>
        <div id="legend"></div>
      </div>

      <div class="sidebar-section">
        <h3>Edge Types</h3>
        <div id="edgeLegend">
          <div class="legend-item">
            <div class="legend-dot" style="background: #3498db;"></div>
            <span>defines</span>
            <span class="legend-count" id="edgeDefines">0</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot" style="background: #9b59b6;"></div>
            <span>implements</span>
            <span class="legend-count" id="edgeImplements">0</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot" style="background: #2ecc71;"></div>
            <span>uses</span>
            <span class="legend-count" id="edgeUses">0</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot" style="background: #8b949e;"></div>
            <span>sibling</span>
            <span class="legend-count" id="edgeSibling">0</span>
          </div>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>Files</h3>
      </div>
      <div id="fileList"></div>
    </div>

    <div id="main">
      <div id="toolbar">
        <button onclick="loadView()">Refresh</button>
        <button id="backBtn" class="secondary" style="display:none" onclick="showFullGraph()">Back</button>
        <button id="fitBtn" class="secondary">Fit</button>
        <button class="secondary" onclick="cy.zoom(cy.zoom() * 1.2)">Zoom +</button>
        <button class="secondary" onclick="cy.zoom(cy.zoom() / 1.2)">Zoom -</button>
        <button class="secondary" onclick="expandAll()">Expand All</button>
        <button class="secondary" onclick="collapseAll()">Collapse All</button>
        <button id="autoFitToggle" class="active" title="Auto-Fit: ON - Click to lock view">[ON] Auto-Fit</button>
        <button id="connectivityToggle" class="secondary" title="Color by Connectivity">Color by Degree</button>
        <select id="lensType" title="Analysis Lens">
          <option value="default">Default View</option>
          <option value="drift">Drift (Surprising)</option>
          <option value="bridges">Bridges</option>
          <option value="backbone">Backbone (k-core)</option>
        </select>
        <div class="spacer"></div>
        <div id="stats"></div>
      </div>
      <div id="cy"></div>
    </div>

    <div id="nodeInfo">
      <h4 id="infoName"></h4>
      <div class="info-row"><span class="info-label">Kind</span><span class="info-value" id="infoKind"></span></div>
      <div class="info-row"><span class="info-label">File</span><span class="info-value" id="infoFile"></span></div>
      <div class="info-row"><span class="info-label">Visibility</span><span class="info-value" id="infoVisibility"></span></div>
      <div class="signature" id="infoSignature"></div>
    </div>
  </div>

  <script>
    // Register fCoSE layout extension
    if (typeof cytoscapeFcose !== 'undefined') {
      cytoscape.use(cytoscapeFcose);
    }

    // Make API URL configurable via URL parameter (?apiPort=3002)
    const urlParams = new URLSearchParams(window.location.search);
    const apiPort = urlParams.get('apiPort') || '3001';
    const API = `http://localhost:${apiPort}`;
    console.log(`ðŸ“¡ Connecting to view service at: ${API}`);
    let cy;
    let allData = null;
    let enabledKinds = new Set(['module', 'class', 'interface', 'function', 'method', 'field', 'property', 'trait']);
    let selectedFile = null;
    let autoFitEnabled = true;
    let isZoomedIn = false;  // Track if we're in zoomed/focused view
    let showMethodsEnabled = false;  // Track if methods should be visible (default: hidden)
    let edgeFilterMode = 'all';  // Track edge filtering: 'all', 'non-synthetic', 'structural'

    // Isolate ring state
    let showIsolateRing = true;
    let fitToConnectedOnly = true;
    let edgeMode = 'all'; // 'off' | 'selection' | 'hover' | 'all'
    let hideExternalEdges = false;  // Hide edges that cross community boundaries

    // ========================================
    // ISOLATE/CONNECTED HELPERS
    // ========================================

    function getIsolates(cyGraph) {
      if (!cyGraph) return cyGraph.collection();
      return cyGraph.nodes('.code').filter(n => n.connectedEdges().length === 0);
    }

    function getConnectedNodes(cyGraph) {
      if (!cyGraph) return cyGraph.collection();
      const isolates = getIsolates(cyGraph);
      return cyGraph.nodes('.code').difference(isolates);
    }

    function getConnectedEdges(cyGraph) {
      const conn = getConnectedNodes(cyGraph);
      return conn.connectedEdges();
    }

    // ========================================
    // EDGE VISIBILITY MODE
    // ========================================

    function applyEdgeMode(cyGraph) {
      if (!cyGraph) return;

      if (edgeMode === 'off') {
        cyGraph.edges().style('display', 'none');
        return;
      }
      if (edgeMode === 'all') {
        // Show all edges, but respect external edge filter
        cyGraph.edges().forEach(edge => {
          if (hideExternalEdges && isExternalEdge(edge)) {
            edge.style('display', 'none');
          } else {
            edge.style('display', 'element');
          }
        });
        return;
      }
      if (edgeMode === 'hover') {
        // hover mode - hide all edges, will be shown on hover
        cyGraph.edges().style('display', 'none');
        return;
      }
      // selection mode - hide all, show only selected node's edges
      cyGraph.edges().style('display', 'none');
      const sel = cyGraph.nodes(':selected');
      if (sel.length > 0) {
        sel.connectedEdges().forEach(edge => {
          if (hideExternalEdges && isExternalEdge(edge)) {
            edge.style('display', 'none');
          } else {
            edge.style('display', 'element');
          }
        });
      }
    }

    // ========================================
    // ISOLATE RING POSITIONER (DETERMINISTIC)
    // ========================================

    function layoutIsolateRing(cyGraph) {
      if (!cyGraph) return;

      const isolates = getIsolates(cyGraph);
      if (!showIsolateRing) {
        isolates.style('display', 'none');
        return;
      }
      isolates.style('display', 'element');
      isolates.addClass('isolate');

      const connected = getConnectedNodes(cyGraph);
      if (connected.length === 0) return;

      // Bounding box of connected graph only
      const bb = connected.boundingBox({ includeLabels: false });
      const cx = (bb.x1 + bb.x2) / 2;
      const cyCenter = (bb.y1 + bb.y2) / 2;

      const w = Math.max(1, bb.w);
      const h = Math.max(1, bb.h);
      const radius = 0.70 * Math.max(w, h) + 120;

      // Stable ordering (positions don't jump between refreshes)
      const sorted = isolates.toArray().sort((a, b) => {
        return String(a.id()).localeCompare(String(b.id()));
      });

      const n = sorted.length;
      if (n === 0) return;

      cyGraph.batch(() => {
        for (let i = 0; i < n; i++) {
          const theta = (2 * Math.PI * i) / n;
          const x = cx + radius * Math.cos(theta);
          const y = cyCenter + radius * Math.sin(theta);
          sorted[i].position({ x, y });
        }
      });
    }

    // ========================================
    // FIT TO CONNECTED ONLY
    // ========================================

    function fitGraph(cyGraph) {
      if (!cyGraph) return;

      if (!fitToConnectedOnly) {
        cyGraph.fit(undefined, 40);
        return;
      }
      const conn = getConnectedNodes(cyGraph);
      if (conn.length > 0) {
        cyGraph.fit(conn, 60);
      } else {
        cyGraph.fit(undefined, 40);
      }
    }

    // ========================================
    // LAYOUT PIPELINE: MAIN LAYOUT THEN RING
    // ========================================

    async function runMainLayoutThenRing(cyGraph, layoutName, layoutConfig) {
      if (!cyGraph) return;

      const connected = getConnectedNodes(cyGraph);
      const isolates = getIsolates(cyGraph);

      // 1) Hide isolates during main layout so they don't affect it
      isolates.style('display', 'none');

      // 2) Run layout ONLY on connected nodes
      if (connected.length > 0 && layoutConfig) {
        return new Promise((resolve) => {
          const layout = connected.layout(layoutConfig);
          layout.one('layoutstop', () => {
            // 3) Place isolates as ring AFTER main layout
            layoutIsolateRing(cyGraph);

            // 4) Fit camera to connected only
            fitGraph(cyGraph);

            // 5) Apply edge mode
            applyEdgeMode(cyGraph);

            resolve();
          });
          layout.run();
        });
      } else {
        // No connected nodes, just show isolates
        layoutIsolateRing(cyGraph);
        fitGraph(cyGraph);
        applyEdgeMode(cyGraph);
      }
    }

    // ========================================
    // UPDATE GRAPH STATS
    // ========================================

    function updateGraphStats(cyGraph) {
      if (!cyGraph) return;

      const isolates = getIsolates(cyGraph);
      const connected = getConnectedNodes(cyGraph);

      const connectedCountEl = document.getElementById('connectedCount');
      const isolateCountEl = document.getElementById('isolateCount');

      if (connectedCountEl) connectedCountEl.textContent = connected.length;
      if (isolateCountEl) isolateCountEl.textContent = isolates.length;
    }

    // Node colors by kind
    const kindColors = {
      'module': '#e74c3c',
      'class': '#3498db',
      'interface': '#9b59b6',
      'function': '#2ecc71',
      'method': '#00bcd4',
      'field': '#f39c12',
      'property': '#e67e22',
      'trait': '#e91e63'
    };

    const kindLabels = {
      'module': 'Modules',
      'class': 'Classes',
      'interface': 'Interfaces',
      'function': 'Functions',
      'method': 'Methods',
      'field': 'Fields',
      'property': 'Properties',
      'trait': 'Traits'
    };

    // Connectivity-based colorscale (isolated=faded, connected=prominent)
    const connectivityColorscale = [
      [0.0, '#e0e0e0'],  // light gray - isolated
      [0.2, '#e8b4d9'],  // pale pink
      [0.4, '#e066a0'],  // pink
      [0.6, '#c41969'],  // magenta
      [0.8, '#8b0a50'],  // dark magenta
      [1.0, '#67001f']   // deep wine - hub nodes
    ];

    // Linear interpolation between two hex colors
    function lerpColor(c1, c2, t) {
      const r1 = parseInt(c1.slice(1,3), 16);
      const g1 = parseInt(c1.slice(3,5), 16);
      const b1 = parseInt(c1.slice(5,7), 16);
      const r2 = parseInt(c2.slice(1,3), 16);
      const g2 = parseInt(c2.slice(3,5), 16);
      const b2 = parseInt(c2.slice(5,7), 16);
      const r = Math.round(r1 + (r2-r1)*t);
      const g = Math.round(g1 + (g2-g1)*t);
      const b = Math.round(b1 + (b2-b1)*t);
      return '#' + [r,g,b].map(x => x.toString(16).padStart(2,'0')).join('');
    }

    // Map normalized value (0-1) to colorscale
    function interpolateColor(val, scale) {
      if (val <= 0) return scale[0][1];
      if (val >= 1) return scale[scale.length-1][1];
      for (let i = 1; i < scale.length; i++) {
        if (val <= scale[i][0]) {
          const [leftPos, leftColor] = scale[i-1];
          const [rightPos, rightColor] = scale[i];
          const t = (val - leftPos) / (rightPos - leftPos);
          return lerpColor(leftColor, rightColor, t);
        }
      }
      return scale[scale.length-1][1];
    }

    // State for connectivity coloring
    let colorByConnectivityEnabled = false;

    // Color nodes by their degree (number of connections)
    function colorByConnectivity() {
      if (!cy) return;
      const nodes = cy.nodes('.code');
      const degrees = nodes.map(n => n.degree());
      const maxDegree = Math.max(...degrees, 1);

      nodes.forEach(node => {
        const normalized = node.degree() / maxDegree;
        node.style('background-color', interpolateColor(normalized, connectivityColorscale));
      });
    }

    // Reset to original kind-based colors
    function resetNodeColors() {
      if (!cy) return;
      cy.nodes('.code').forEach(node => {
        const kind = node.data('kind');
        node.style('background-color', kindColors[kind] || '#888');
      });
    }

    // Mark suspicious nodes for data quality visualization
    function markSuspiciousNodes() {
      if (!cy) return;
      cy.nodes().forEach(node => {
        const kind = node.data('kind');
        const degree = node.degree();
        const hasParent = node.data('parent');
        const parentExists = hasParent && cy.getElementById(hasParent).length > 0;

        // Remove existing classes
        node.removeClass('orphaned suspicious-isolated expected-isolated');

        // Orphaned (has parent reference but parent missing from graph)
        if (hasParent && !parentExists) {
          node.addClass('orphaned');
        }

        // Suspicious isolated (function/method with no connections)
        if (degree === 0 && (kind === 'function' || kind === 'method')) {
          node.addClass('suspicious-isolated');
        }

        // Expected isolated (interface/type definitions)
        if (degree === 0 && kind === 'interface') {
          node.addClass('expected-isolated');
        }
      });
    }

    // Apply level-of-detail visibility (hide/show methods)
    function applyLevelOfDetail() {
      if (!cy) return;

      if (showMethodsEnabled) {
        // Show all methods
        cy.nodes('[kind = "method"]').style('display', 'element');
      } else {
        // Hide methods by default
        cy.nodes('[kind = "method"]').style('display', 'none');
      }
    }

    // Toggle method visibility for a specific parent node (click-to-expand)
    function toggleChildrenVisibility(parentNode) {
      if (!cy || !parentNode) return;

      const children = parentNode.children('[kind = "method"]');
      if (children.length === 0) return;

      // Check if any children are currently hidden
      const anyHidden = children.some(child => child.style('display') === 'none');

      if (anyHidden) {
        // Expand: show all children
        children.style('display', 'element');
      } else {
        // Collapse: hide all children
        children.style('display', 'none');
      }
    }

    // ========================================
    // ELK LAYOUT INTEGRATION
    // ========================================

    // Helper to POST JSON to server
    async function postJSON(url, body) {
      const res = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      });
      if (!res.ok) {
        const text = await res.text();
        throw new Error(`HTTP ${res.status}: ${text}`);
      }
      return await res.json();
    }

    // Build ELK payload from visible Cytoscape nodes/edges
    // Server expects {nodes: Node[], edges: Edge[]} format
    // topLevelOnly: if true, only include nodes without parents (for global layout)
    function buildElkPayloadFromCy(cy, topLevelOnly = false) {
      let nodesToLayout = cy.nodes(':visible');
      if (topLevelOnly) {
        nodesToLayout = nodesToLayout.filter(n => !n.data('parent'));
      }

      const nodes = nodesToLayout.map(n => {
        const data = n.data();
        // Build minimal Node object from Cytoscape data
        return {
          node_id: data.id,
          kind: data.kind || 'module',
          name: data.label || data.name || data.id,
          file: data.file || 'unknown',
          route: data.route || data.id,
          span: data.span || { start: { line: 0, col: 0 }, end: { line: 0, col: 0 } },
          visibility: data.visibility || 'public',
          language: data.language || 'typescript',
          parent: topLevelOnly ? undefined : data.parent,  // Skip parent when doing top-level only
          signature: data.signature,
        };
      });

      const nodeIds = new Set(nodes.map(n => n.node_id));

      const edges = cy.edges(':visible').map(e => {
        const data = e.data();
        // Check if edge connects nodes in our layout set
        if (!nodeIds.has(data.source) || !nodeIds.has(data.target)) {
          return null;  // Skip edges to/from filtered-out nodes
        }

        // Apply weight penalty to synthetic edges
        const isSynthetic = data.kind === 'sibling' || (data.id && data.id.startsWith('synth_'));
        const layoutWeight = isSynthetic ? 0.1 : 1.0;

        return {
          edge_id: data.id,
          kind: data.kind || 'uses',
          src: data.source,
          dst: data.target,
          confidence: data.confidence || 1.0,
          evidence: data.evidence || ['visual'],
          layoutWeight: layoutWeight,  // Weight penalty for synthetic edges
        };
      }).filter(e => e !== null);

      return { nodes, edges };
    }

    // Apply ELK layout positions to Cytoscape
    function applyElkLayoutToCy(cy, positions) {
      // Server returns {positions: {nodeId: {x, y}}}
      cy.batch(() => {
        cy.nodes().forEach(n => {
          const pos = positions[n.id()];
          if (pos && typeof pos.x === 'number' && typeof pos.y === 'number') {
            n.position(pos);
          }
        });
      });

      cy.layout({ name: 'preset', fit: true, animate: true, animationDuration: 400 }).run();
    }

    // Local layout for children inside a container node
    // Used when expanding a compound node in detail mode
    function layoutChildrenInsideContainer(parentNode) {
      if (!parentNode || !cy) return;

      const children = parentNode.children();
      if (children.length === 0) return;

      // Choose layout based on child count
      const layoutName = children.length <= 6 ? 'grid' : 'circle';

      children.layout({
        name: layoutName,
        fit: false,
        animate: true,
        animationDuration: 300,
        boundingBox: parentNode.boundingBox(),
        avoidOverlap: true,
        padding: 10
      }).run();
    }

    // Run ELK layout via server
    async function runElkLayout(cy) {
      try {
        const payload = buildElkPayloadFromCy(cy);
        console.log('Sending ELK layout request with', payload.nodes.length, 'nodes');

        const result = await postJSON(`${API}/layout/elk`, payload);

        // Server returns {positions: {nodeId: {x, y}}}
        if (!result.positions) {
          throw new Error('Server response missing positions field');
        }

        applyElkLayoutToCy(cy, result.positions);
        console.log('ELK layout applied successfully');

        // Apply post-layout operations
        markSuspiciousNodes();
        if (colorByConnectivityEnabled) {
          colorByConnectivity();
        }
        applyLevelOfDetail();
      } catch (err) {
        console.error('ELK layout failed:', err);
        alert('ELK layout failed: ' + err.message + '\n\nMake sure the view service is running on ' + API);
      }
    }

    // ========================================
    // COMMUNITY-BASED VISUALIZATION
    // ========================================

    // Edge weights by type - higher = stronger relationship
    const EDGE_WEIGHTS = {
      calls: 1.0,
      imports: 0.4,
      inherits: 0.7,
      implements: 0.7,
      uses: 0.5,
      sibling: 0.1,
      defines: 0.3
    };

    const HUB_THRESHOLD = 20;  // Nodes with degree > this are hubs
    const MAX_ITERATIONS = 50;  // For community detection

    // Get weighted edge value
    function getEdgeWeight(edge) {
      const kind = edge.data('kind') || 'uses';
      const baseWeight = EDGE_WEIGHTS[kind] || 0.5;

      // Apply hub penalty to source and target
      const srcPenalty = getHubPenalty(edge.source());
      const tgtPenalty = getHubPenalty(edge.target());

      return baseWeight * srcPenalty * tgtPenalty;
    }

    // Penalize hub nodes to prevent them from dominating communities
    function getHubPenalty(node) {
      const degree = node.degree();
      if (degree > HUB_THRESHOLD) {
        return HUB_THRESHOLD / degree;  // Diminishing returns
      }
      return 1.0;
    }

    // Fisher-Yates shuffle for random iteration order
    function shuffle(array) {
      const arr = [...array];
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    // Label Propagation Community Detection
    function detectCommunities() {
      const nodes = cy.nodes('.code');
      const labels = new Map();

      // Initialize: each node in its own community
      nodes.forEach((node, i) => labels.set(node.id(), i));

      // Iterate until convergence
      for (let iter = 0; iter < MAX_ITERATIONS; iter++) {
        let changed = false;
        const nodeOrder = shuffle([...nodes]);  // Random order for stability

        nodeOrder.forEach(node => {
          const neighbors = node.neighborhood().nodes();
          if (neighbors.length === 0) return;

          // Count weighted votes from neighbors
          const votes = new Map();
          neighbors.forEach(neighbor => {
            const edge = node.edgesWith(neighbor)[0];
            const weight = edge ? getEdgeWeight(edge) : 0.5;
            const label = labels.get(neighbor.id());
            if (label !== undefined) {
              votes.set(label, (votes.get(label) || 0) + weight);
            }
          });

          // Find label with most votes
          let bestLabel = labels.get(node.id());
          let bestVotes = 0;
          votes.forEach((v, l) => {
            if (v > bestVotes) {
              bestVotes = v;
              bestLabel = l;
            }
          });

          if (bestLabel !== labels.get(node.id())) {
            labels.set(node.id(), bestLabel);
            changed = true;
          }
        });

        if (!changed) break;
      }

      // Normalize labels to sequential IDs
      const uniqueLabels = [...new Set(labels.values())];
      const labelMap = new Map(uniqueLabels.map((l, i) => [l, i]));
      const normalized = new Map();
      labels.forEach((label, nodeId) => {
        normalized.set(nodeId, labelMap.get(label));
      });

      return normalized;
    }

    // Sort nodes within a community to minimize edge crossings
    // Places highly-connected nodes centrally, interleaving around center position
    function sortNodesWithinCommunity(nodes) {
      if (nodes.length <= 2) return nodes;

      // Build adjacency info within this community
      const nodeSet = new Set(nodes.map(n => n.id()));
      const connectionCounts = new Map();

      nodes.forEach(node => {
        let count = 0;
        node.connectedEdges().forEach(edge => {
          const otherId = edge.source().id() === node.id()
            ? edge.target().id() : edge.source().id();
          if (nodeSet.has(otherId)) count++;
        });
        connectionCounts.set(node.id(), count);
      });

      // Sort by connection count (most connected first)
      const sorted = [...nodes].sort((a, b) =>
        connectionCounts.get(b.id()) - connectionCounts.get(a.id())
      );

      // Interleave: place most connected at center, then alternate +/- positions
      const result = new Array(sorted.length);
      let left = Math.floor(sorted.length / 2);
      let right = left + 1;
      let useLeft = true;

      sorted.forEach((node, i) => {
        if (i === 0) {
          result[left] = node;
        } else if (useLeft && left > 0) {
          result[--left] = node;
          useLeft = false;
        } else if (right < sorted.length) {
          result[right++] = node;
          useLeft = true;
        } else {
          result[--left] = node;
        }
      });

      return result.filter(n => n);
    }

    // Classify an edge as internal or external based on community membership
    function isExternalEdge(edge) {
      const sourceComm = edge.source().data('communityId');
      const targetComm = edge.target().data('communityId');
      // External if endpoints are in different communities (or if community not set)
      return sourceComm !== undefined && targetComm !== undefined && sourceComm !== targetComm;
    }

    // Two-level community layout
    function communityLayout() {
      const params = getLayoutParams();
      if (!params) return;

      const communities = detectCommunities();

      // Group nodes by community and store communityId on each node
      const groups = new Map();
      communities.forEach((communityId, nodeId) => {
        if (!groups.has(communityId)) groups.set(communityId, []);
        const node = cy.getElementById(nodeId);
        if (node.length > 0) {
          node.data('communityId', communityId);  // Store community membership
          groups.get(communityId).push(node);
        }
      });

      // Sort communities by size (largest first)
      const sortedComms = [...groups.entries()]
        .sort((a, b) => b[1].length - a[1].length);

      // Macro layout: arrange community centroids on circle
      const numComms = sortedComms.length;
      if (numComms === 0) return;

      sortedComms.forEach(([commId, nodes], index) => {
        const angle = (2 * Math.PI * index / numComms) - Math.PI / 2;
        const centroidX = params.centerX + params.mainRadius * Math.cos(angle);
        const centroidY = params.centerY + params.mainRadius * Math.sin(angle);

        // Micro layout: circular within community (sorted to minimize edge crossings)
        if (nodes.length === 1) {
          nodes[0].position({ x: centroidX, y: centroidY });
        } else {
          const subRadius = getSubCircleRadius(nodes.length, params);
          const sortedNodes = sortNodesWithinCommunity(nodes);
          sortedNodes.forEach((node, i) => {
            const nodeAngle = (2 * Math.PI * i / sortedNodes.length);
            node.position({
              x: centroidX + subRadius * Math.cos(nodeAngle),
              y: centroidY + subRadius * Math.sin(nodeAngle)
            });
          });
        }
      });

      // Layout isolated nodes in outer ring
      const isolated = cy.nodes('.code').filter(n => n.degree() === 0);
      isolated.addClass('isolated');

      if (isolated.length > 0) {
        isolated.forEach((node, i) => {
          const angle = (2 * Math.PI * i / isolated.length) + Math.PI / 6;
          node.position({
            x: params.centerX + params.outerRadius * Math.cos(angle),
            y: params.centerY + params.outerRadius * Math.sin(angle)
          });
        });
      }

      cy.fit(undefined, 50);

      // Return community count for stats
      return { numCommunities: numComms, isolated: isolated.length };
    }

    // ========================================
    // METRICS CALCULATION
    // ========================================

    // Simple BFS for betweenness approximation
    function bfs(source) {
      const distances = new Map();
      const paths = new Map();
      const queue = [source];
      distances.set(source.id(), 0);
      paths.set(source.id(), 1);

      while (queue.length > 0) {
        const current = queue.shift();
        const currentDist = distances.get(current.id());

        current.neighborhood().nodes().forEach(neighbor => {
          if (!distances.has(neighbor.id())) {
            distances.set(neighbor.id(), currentDist + 1);
            paths.set(neighbor.id(), paths.get(current.id()));
            queue.push(neighbor);
          } else if (distances.get(neighbor.id()) === currentDist + 1) {
            paths.set(neighbor.id(), paths.get(neighbor.id()) + paths.get(current.id()));
          }
        });
      }

      return { distances, paths };
    }

    // Approximate betweenness centrality (sampling-based for performance)
    function calculateBetweenness() {
      const betweenness = new Map();
      const nodes = cy.nodes('.code');
      nodes.forEach(n => betweenness.set(n.id(), 0));

      // Sample ~20% of nodes as sources for BFS
      const sampleSize = Math.min(50, Math.ceil(nodes.length * 0.2));
      const sources = shuffle([...nodes]).slice(0, sampleSize);

      sources.forEach(source => {
        const { paths } = bfs(source);
        paths.forEach((pathCount, nodeId) => {
          betweenness.set(nodeId, betweenness.get(nodeId) + pathCount);
        });
      });

      // Normalize
      const max = Math.max(...betweenness.values(), 1);
      betweenness.forEach((v, k) => betweenness.set(k, v / max));

      return betweenness;
    }

    // Surprise score for edges - find unexpected coupling
    function calculateSurpriseScores() {
      const totalEdges = cy.edges().length;
      if (totalEdges === 0) return new Map();

      const surprises = new Map();

      cy.edges().forEach(edge => {
        const degA = edge.source().degree();
        const degB = edge.target().degree();
        const expected = (degA * degB) / (2 * totalEdges);
        const observed = getEdgeWeight(edge);
        const surprise = observed / Math.max(expected, 0.001);
        surprises.set(edge.id(), surprise);
      });

      return surprises;
    }

    // ========================================
    // LENSES
    // ========================================

    let currentLens = 'default';
    let betweennessCache = null;
    let surpriseCache = null;

    function clearLensCache() {
      betweennessCache = null;
      surpriseCache = null;
    }

    function applyLens(lens) {
      currentLens = lens;

      // Reset styles
      cy.nodes().removeClass('lens-highlight lens-fade');
      cy.edges().removeClass('lens-highlight lens-fade');

      switch (lens) {
        case 'drift':
          applyDriftLens();
          break;
        case 'bridges':
          applyBridgesLens();
          break;
        case 'backbone':
          applyBackboneLens();
          break;
        default:
          // Default view - show everything
          break;
      }
    }

    function applyDriftLens() {
      if (!surpriseCache) surpriseCache = calculateSurpriseScores();

      // Highlight top 10% surprising edges
      const sorted = [...surpriseCache.entries()].sort((a, b) => b[1] - a[1]);
      const topN = Math.max(1, Math.ceil(sorted.length * 0.1));

      sorted.slice(0, topN).forEach(([edgeId]) => {
        const edge = cy.getElementById(edgeId);
        if (edge.length > 0) {
          edge.addClass('lens-highlight');
          edge.source().addClass('lens-highlight');
          edge.target().addClass('lens-highlight');
        }
      });

      // Fade non-highlighted
      cy.elements().not('.lens-highlight').addClass('lens-fade');
    }

    function applyBridgesLens() {
      if (!betweennessCache) betweennessCache = calculateBetweenness();

      // Highlight top 10 bridge nodes
      const sorted = [...betweennessCache.entries()].sort((a, b) => b[1] - a[1]);
      sorted.slice(0, 10).forEach(([nodeId]) => {
        const node = cy.getElementById(nodeId);
        if (node.length > 0) {
          node.addClass('lens-highlight');
          node.connectedEdges().addClass('lens-highlight');
        }
      });

      cy.elements().not('.lens-highlight').addClass('lens-fade');
    }

    function applyBackboneLens() {
      // Show k-core (nodes with at least k connections to other k-core nodes)
      const k = 3;
      let core = cy.nodes('.code').filter(n => n.degree() >= k);

      // Iteratively remove nodes that don't have k neighbors in core
      let changed = true;
      while (changed) {
        changed = false;
        const newCore = core.filter(n => {
          const coreNeighbors = n.neighborhood().nodes().intersection(core).length;
          if (coreNeighbors < k) {
            changed = true;
            return false;
          }
          return true;
        });
        core = newCore;
      }

      if (core.length > 0) {
        core.addClass('lens-highlight');
        core.edgesWith(core).addClass('lens-highlight');
      }
      cy.elements().not('.lens-highlight').addClass('lens-fade');
    }

    // ========================================
    // ORIGINAL HELPER FUNCTIONS
    // ========================================

    // Semantic zoom state
    let zoomLevel = 0;  // 0=overview, 1=cluster expanded
    let focusedCluster = null;
    const ZOOM_THRESHOLD = 1.5;

    // Semantic zoom modes
    const ZOOM_MODE = {
      OVERVIEW: 'overview',
      STRUCTURE: 'structure',
      DETAIL: 'detail'
    };

    // Zoom thresholds (updated: Z1=0.7, Z2=1.4)
    const ZOOM_THRESHOLDS = {
      OVERVIEW_MAX: 0.7,   // < 0.7 = overview mode
      STRUCTURE_MAX: 1.4   // 0.7-1.4 = structure mode, > 1.4 = detail mode
    };

    let currentZoomMode = ZOOM_MODE.STRUCTURE;
    let previousZoomMode = null;
    let zoomDebounceTimer = null;
    const ZOOM_DEBOUNCE_MS = 50;

    function getZoomModeFromLevel(zoomLevel) {
      if (zoomLevel < ZOOM_THRESHOLDS.OVERVIEW_MAX) return ZOOM_MODE.OVERVIEW;
      if (zoomLevel < ZOOM_THRESHOLDS.STRUCTURE_MAX) return ZOOM_MODE.STRUCTURE;
      return ZOOM_MODE.DETAIL;
    }

    // Debounce helper
    function debounce(fn, delay) {
      let timer;
      return (...args) => {
        clearTimeout(timer);
        timer = setTimeout(() => fn(...args), delay);
      };
    }

    // Dynamic viewport-based sizing - all sizes scale with viewport
    let layoutParams = null;

    function getLayoutParams() {
      const container = document.getElementById('cy');
      if (!container) return null;
      const minDim = Math.min(container.clientWidth, container.clientHeight);
      const vu = minDim / 100;  // 1 vu = 1% of smaller dimension

      return {
        vu: vu,
        nodeSize: Math.max(8, Math.round(1.5 * vu)),
        isolatedNodeSize: Math.max(5, Math.round(1.0 * vu)),
        labelFontSize: Math.max(9, Math.round(1.4 * vu)) + 'px',
        mainRadius: 35 * vu,
        subRadiusMin: 8 * vu,       // Doubled from 4 * vu for more spacing
        subRadiusMax: 25 * vu,      // Increased from 15 * vu
        subRadiusFactor: 2.5 * vu,  // Doubled from 1.2 * vu for more space per node
        outerRadius: 52 * vu,
        centerX: container.clientWidth / 2,
        centerY: container.clientHeight / 2
      };
    }

    // Get sub-circle radius based on node count
    function getSubCircleRadius(nodeCount, params) {
      const baseRadius = nodeCount * params.subRadiusFactor;
      return Math.max(params.subRadiusMin, Math.min(params.subRadiusMax, baseRadius));
    }

    // Group connected nodes by file
    function getFileGroups() {
      const groups = {};
      cy.nodes('.code').filter(n => n.degree() > 0).forEach(n => {
        const file = n.data('file') || 'unknown';
        if (!groups[file]) groups[file] = [];
        groups[file].push(n);
      });
      return groups;
    }

    // Sort groups by connectivity to minimize edge crossings
    function sortGroupsByConnectivity(groups) {
      const fileNames = Object.keys(groups);
      if (fileNames.length <= 2) return fileNames;

      // Calculate inter-group edge counts
      const groupEdges = {};
      fileNames.forEach(f1 => {
        groupEdges[f1] = {};
        fileNames.forEach(f2 => {
          groupEdges[f1][f2] = 0;
        });
      });

      // Count edges between groups
      cy.edges().forEach(edge => {
        const srcFile = edge.source().data('file') || 'unknown';
        const tgtFile = edge.target().data('file') || 'unknown';
        if (srcFile !== tgtFile && groupEdges[srcFile] && groupEdges[srcFile][tgtFile] !== undefined) {
          groupEdges[srcFile][tgtFile]++;
          groupEdges[tgtFile][srcFile]++;
        }
      });

      // Greedy ordering: start with largest group, add most-connected next
      const sorted = [];
      const remaining = new Set(fileNames);

      // Start with group that has most nodes
      let current = fileNames.reduce((a, b) =>
        groups[a].length > groups[b].length ? a : b
      );
      sorted.push(current);
      remaining.delete(current);

      while (remaining.size > 0) {
        let best = null;
        let bestScore = -1;
        remaining.forEach(f => {
          const score = groupEdges[current][f] || 0;
          if (score > bestScore) {
            bestScore = score;
            best = f;
          }
        });
        if (best) {
          sorted.push(best);
          remaining.delete(best);
          current = best;
        } else {
          // No connections, just pick first remaining
          const next = remaining.values().next().value;
          sorted.push(next);
          remaining.delete(next);
          current = next;
        }
      }

      return sorted;
    }

    // Layout nodes in sub-circles grouped by file
    function layoutSubCircles() {
      const params = getLayoutParams();
      if (!params) return;

      const groups = getFileGroups();
      const sortedFiles = sortGroupsByConnectivity(groups);
      const numGroups = sortedFiles.length;

      if (numGroups === 0) return;

      // Position each group's centroid around the main circle
      sortedFiles.forEach((file, index) => {
        const nodes = groups[file];
        const angle = (2 * Math.PI * index / numGroups) - Math.PI / 2;  // Start at top
        const centroidX = params.centerX + params.mainRadius * Math.cos(angle);
        const centroidY = params.centerY + params.mainRadius * Math.sin(angle);

        // Calculate sub-circle radius based on node count
        const subRadius = getSubCircleRadius(nodes.length, params);

        // Position each node in sub-circle around centroid
        nodes.forEach((node, nodeIndex) => {
          if (nodes.length === 1) {
            // Single node - place at centroid
            node.position({ x: centroidX, y: centroidY });
          } else {
            const nodeAngle = (2 * Math.PI * nodeIndex / nodes.length);
            const x = centroidX + subRadius * Math.cos(nodeAngle);
            const y = centroidY + subRadius * Math.sin(nodeAngle);
            node.position({ x, y });
          }
        });
      });

      // Layout isolated nodes in outer ring
      const isolatedNodes = cy.nodes('.code').filter(n => n.degree() === 0);
      isolatedNodes.addClass('isolated');

      if (isolatedNodes.length > 0) {
        isolatedNodes.forEach((node, index) => {
          const angle = (2 * Math.PI * index / isolatedNodes.length) + Math.PI / 6;
          const x = params.centerX + params.outerRadius * Math.cos(angle);
          const y = params.centerY + params.outerRadius * Math.sin(angle);
          node.position({ x, y });
        });
      }

      cy.fit(undefined, 50);
    }

    // Update node styles with dynamic sizes
    function updateNodeStyles() {
      if (!cy) return;
      layoutParams = getLayoutParams();
      if (!layoutParams) return;

      cy.style()
        .selector('node.code')
        .style({
          'width': layoutParams.nodeSize,
          'height': layoutParams.nodeSize
        })
        .selector('node.isolated')
        .style({
          'width': layoutParams.isolatedNodeSize,
          'height': layoutParams.isolatedNodeSize
        })
        .update();
    }

    // ========================================
    // SEMANTIC ZOOM STYLE FUNCTIONS
    // ========================================

    // Overview mode: viewport-scaled dots with small labels
    function getOverviewStyles() {
      if (!layoutParams) layoutParams = getLayoutParams();
      const nodeSize = layoutParams ? layoutParams.nodeSize : 12;
      const fontSize = Math.max(7, Math.round(nodeSize * 0.7)) + 'px';
      return [
        { selector: ':parent', style: {
          'width': nodeSize * 1.5,
          'height': nodeSize * 1.5,
          'shape': 'ellipse',
          'label': 'data(shortLabel)',
          'font-size': fontSize,
          'color': '#e0e0e0',
          'text-opacity': 0.8,
          'padding': '0px',
          'background-opacity': 0.8
        }},
        { selector: 'node.code', style: {
          'width': nodeSize,
          'height': nodeSize,
          'shape': 'ellipse',
          'label': 'data(shortLabel)',
          'font-size': fontSize,
          'color': '#e0e0e0',
          'text-opacity': 0.8
        }},
        { selector: 'node[kind="method"]', style: {
          'display': 'none'
        }},
        { selector: 'edge', style: {
          'width': 0.5,
          'opacity': 0.4
        }}
      ];
    }

    // Structure mode: Icons with truncated labels below
    function getStructureStyles() {
      if (!layoutParams) layoutParams = getLayoutParams();
      const nodeSize = layoutParams ? layoutParams.nodeSize : 12;
      const fontSize = layoutParams ? layoutParams.labelFontSize : '9px';
      return [
        { selector: ':parent', style: {
          'shape': 'round-rectangle',
          'label': 'data(shortLabel)',
          'text-valign': 'bottom',
          'text-margin-y': 6,
          'padding': '10px',
          'font-size': fontSize,
          'color': '#e0e0e0',
          'background-opacity': 0.6
        }},
        { selector: 'node.code', style: {
          'width': nodeSize,
          'height': nodeSize,
          'shape': 'ellipse',
          'label': 'data(shortLabel)',
          'text-valign': 'bottom',
          'text-margin-y': 4,
          'font-size': fontSize,
          'color': '#e0e0e0'
        }},
        { selector: 'node[kind="method"]', style: {
          'display': 'none'
        }},
        { selector: 'edge', style: {
          'width': 1,
          'opacity': 0.7
        }}
      ];
    }

    // Detail mode: Full containers, auto-fit children, methods visible
    function getDetailStyles() {
      if (!layoutParams) layoutParams = getLayoutParams();
      const nodeSize = layoutParams ? Math.round(layoutParams.nodeSize * 1.2) : 14;
      const fontSize = layoutParams ? layoutParams.labelFontSize : '10px';
      return [
        { selector: ':parent', style: {
          'width': null,  // auto-fit
          'height': null,  // auto-fit
          'shape': 'round-rectangle',
          'label': 'data(label)',
          'text-valign': 'top',
          'text-margin-y': -10,
          'padding': '20px',
          'font-size': fontSize,
          'color': '#e0e0e0',
          'background-opacity': 0.6
        }},
        { selector: 'node.code', style: {
          'width': nodeSize,
          'height': nodeSize,
          'shape': 'ellipse',
          'label': 'data(label)',
          'text-valign': 'top',
          'text-margin-y': -8,
          'font-size': fontSize,
          'color': '#e0e0e0',
          'text-background-color': '#333',
          'text-background-opacity': 0.9,
          'text-background-padding': '2px'
        }},
        { selector: 'node[kind="method"]', style: {
          'display': 'element'
        }},
        { selector: 'edge', style: {
          'width': 1.5,
          'opacity': 1
        }}
      ];
    }

    // Apply styles for a given zoom mode
    function applyZoomModeStyles(mode) {
      if (!cy) return;

      const modeStyles = mode === ZOOM_MODE.OVERVIEW ? getOverviewStyles()
                       : mode === ZOOM_MODE.STRUCTURE ? getStructureStyles()
                       : getDetailStyles();

      cy.batch(() => {
        modeStyles.forEach(({selector, style}) => {
          cy.elements(selector).forEach(ele => {
            Object.entries(style).forEach(([prop, val]) => {
              if (val !== null) {
                ele.style(prop, val);
              } else {
                // For auto-fit, remove the style override
                ele.removeCss(prop);
              }
            });
          });
        });
      });

      // Force style refresh to ensure zoom mode overrides apply
      cy.style().update();

      // At overview, hide edges entirely. Otherwise, apply edge mode.
      if (mode === ZOOM_MODE.OVERVIEW) {
        cy.edges().style('display', 'none');
      } else {
        applyEdgeMode(cy);
      }

      // Keep isolate ring properly positioned
      layoutIsolateRing(cy);

      updateZoomModeIndicator(mode);
    }

    // Update UI indicator for current zoom mode
    function updateZoomModeIndicator(mode) {
      const stats = document.getElementById('stats');
      const currentText = stats.textContent;
      // Remove any existing mode indicator
      const baseText = currentText.replace(/ \| (overview|structure|detail)$/, '');
      stats.textContent = `${baseText} | ${mode}`;
    }

    function initCytoscape(elements) {
      if (cy) cy.destroy();

      cy = cytoscape({
        container: document.getElementById('cy'),
        elements: elements,
        style: [
          // Compound nodes (files)
          {
            selector: 'node.file',
            style: {
              'label': 'data(label)',
              'text-valign': 'top',
              'text-halign': 'center',
              'background-color': '#1e3a5f',
              'background-opacity': 0.9,
              'border-width': 1,
              'border-color': '#4a90c2',
              'font-size': '11px',
              'color': '#90caf9',
              'padding': '20px',
              'shape': 'round-rectangle',
              'text-margin-y': -8,
              'z-index': 1
            }
          },
          // Regular nodes - small circles, no labels by default (fixed sizes for zoom mode override)
          {
            selector: 'node.code',
            style: {
              'label': '',  // No label by default - shown on hover
              'background-color': (ele) => kindColors[ele.data('kind')] || '#888',
              'width': 12,   // Fixed size - zoom modes will override
              'height': 12,  // Fixed size - zoom modes will override
              'shape': 'ellipse',
              'border-width': 1,
              'border-color': '#888'
            }
          },
          // Isolated nodes - smaller and faded
          {
            selector: 'node.isolated',
            style: {
              'width': 10,   // Fixed size
              'height': 10,  // Fixed size
              'opacity': 0.5
            }
          },
          // Show label on selected nodes
          {
            selector: 'node.code:selected',
            style: {
              'label': 'data(label)',
              'font-size': (ele) => (layoutParams ? layoutParams.labelFontSize : '12px'),
              'color': '#e0e0e0',
              'text-valign': 'top',
              'text-margin-y': -8,
              'text-background-color': '#333',
              'text-background-opacity': 0.9,
              'text-background-padding': '3px'
            }
          },
          // Highlighted node
          {
            selector: 'node.highlighted',
            style: {
              'border-width': 3,
              'border-color': '#f0883e'
            }
          },
          // Compound nodes (parent containers)
          {
            selector: ':parent',
            style: {
              'label': 'data(label)',
              'text-valign': 'top',
              'text-halign': 'center',
              'background-color': '#2d2d44',
              'background-opacity': 0.8,
              'border-width': 2,
              'border-color': '#555',
              'border-style': 'dashed',
              'padding': '20px',
              'shape': 'round-rectangle',
              'font-size': '12px',
              'color': '#e0e0e0',
              'text-margin-y': -10,
              'z-index': 0,
              'z-compound-depth': 'bottom',  // Render parent nodes at bottom layer
              'compound-sizing-wrt-labels': 'exclude'  // Auto-fit: don't include labels in size calc
              // Removed min-width/min-height to allow zoom modes to resize
            }
          },
          // Edges
          {
            selector: 'edge',
            style: {
              'width': 1.5,
              'line-color': '#8b949e',
              'target-arrow-color': '#8b949e',
              'target-arrow-shape': 'triangle',
              'curve-style': 'bezier',
              'arrow-scale': 0.8,
              'z-index': 999,
              'z-compound-depth': 'top',
              'z-index-compare': 'manual'  // Bypass "edges under nodes" convention
            }
          },
          // Contains edges (file -> nodes)
          {
            selector: 'edge.contains',
            style: {
              'display': 'none'
            }
          },
          // Relationship edges
          {
            selector: 'edge.relationship',
            style: {
              'line-color': '#58a6ff',
              'target-arrow-color': '#58a6ff',
              'width': 2
            }
          },
          // Defines edges (class -> method)
          {
            selector: 'edge[kind="defines"]',
            style: {
              'line-color': '#3498db',
              'target-arrow-color': '#3498db',
              'line-style': 'solid',
              'width': 2,
              'target-arrow-shape': 'triangle'
            }
          },
          // Sibling edges (co-location)
          {
            selector: 'edge[kind="sibling"]',
            style: {
              'line-color': '#9e9e9e',
              'target-arrow-color': '#9e9e9e',
              'line-style': 'dashed',
              'width': 1,
              'target-arrow-shape': 'none'
            }
          },
          // Implements edges
          {
            selector: 'edge[kind="implements"]',
            style: {
              'line-color': '#9b59b6',
              'target-arrow-color': '#9b59b6',
              'line-style': 'dotted',
              'width': 2,
              'target-arrow-shape': 'triangle-backcurve'
            }
          },
          // Uses edges (cross-file references)
          {
            selector: 'edge[kind="uses"]',
            style: {
              'line-color': '#2ecc71',
              'target-arrow-color': '#2ecc71',
              'line-style': 'solid',
              'width': 1.5,
              'target-arrow-shape': 'vee'
            }
          },
          // Orphaned node (has parent reference but parent missing)
          {
            selector: 'node.orphaned',
            style: {
              'border-style': 'dashed',
              'border-width': 2,
              'border-color': '#f59e0b'
            }
          },
          // Suspicious isolated node (function/method with no connections)
          {
            selector: 'node.suspicious-isolated',
            style: {
              'border-width': 2,
              'border-color': '#fbbf24',
              'background-opacity': 0.7
            }
          },
          // Expected isolated node (interface/type - faded)
          {
            selector: 'node.expected-isolated',
            style: {
              'background-opacity': 0.5
            }
          },
          // Lens highlight styles
          {
            selector: 'node.lens-highlight',
            style: {
              'border-width': 3,
              'border-color': '#ff6b6b',
              'z-index': 999
            }
          },
          {
            selector: 'edge.lens-highlight',
            style: {
              'width': 3,
              'line-color': '#ff6b6b',
              'target-arrow-color': '#ff6b6b',
              'z-index': 999
            }
          },
          // Isolate ring style
          {
            selector: 'node.isolate',
            style: {
              'shape': 'ellipse',
              'width': 10,
              'height': 10,
              'opacity': 0.7
            }
          }
        ],
        layout: { name: 'preset' },
        wheelSensitivity: 0.15,  // Smoother zoom control
        minZoom: 0.1,            // Better control at far zoom
        maxZoom: 3               // Reduced max zoom
      });

      // Node click handler - zoom into node when in circle layout, or toggle children
      cy.on('tap', 'node.code', (e) => {
        const node = e.target;
        showNodeInfo(node.data());
        cy.nodes().removeClass('highlighted');
        node.addClass('highlighted');

        // Check if this is a parent node with hidden children
        const isParent = node.isParent();
        if (isParent && !showMethodsEnabled) {
          // Click-to-expand: toggle visibility of child methods
          toggleChildrenVisibility(node);
        } else {
          // Click-to-zoom: if in circle layout and not already zoomed, zoom into node
          const layoutType = document.getElementById('layoutType').value;
          if (layoutType === 'circle' && !isZoomedIn && node.degree() > 0) {
            zoomIntoNode(node);
          }
        }
      });

      // Background click - hide info panel
      cy.on('tap', (e) => {
        if (e.target === cy) {
          document.getElementById('nodeInfo').classList.remove('visible');
          cy.nodes().removeClass('highlighted');
        }
      });

      // Double-click background to return to full view
      cy.on('dbltap', (e) => {
        if (e.target === cy && isZoomedIn) {
          showFullGraph();
        }
      });

      // Hover label behavior - show label on mouseover
      cy.on('mouseover', 'node.code', (e) => {
        const node = e.target;
        const fontSize = layoutParams ? layoutParams.labelFontSize : '11px';
        node.style({
          'label': node.data('label'),
          'font-size': fontSize,
          'color': '#24292f',
          'text-valign': 'top',
          'text-margin-y': -8,
          'text-background-color': '#fff',
          'text-background-opacity': 0.9,
          'text-background-padding': '3px'
        });
      });

      cy.on('mouseout', 'node.code', (e) => {
        const node = e.target;
        if (!node.selected()) {
          node.style('label', '');
        }
      });

      // Select/unselect handlers for edge mode
      cy.on('select unselect', 'node', () => {
        if (edgeMode === 'selection') {
          applyEdgeMode(cy);
        }
      });

      // Hover handlers for edge reveal mode
      cy.on('mouseover', 'node', function(e) {
        if (edgeMode !== 'hover') return;
        const node = e.target;

        // If this is a parent/container, get all children; otherwise just this node
        const nodesInScope = node.isParent() ? node.descendants().add(node) : node;

        // Show edges connected to nodes in scope (respecting external edge filter)
        const connectedEdges = nodesInScope.connectedEdges();
        connectedEdges.forEach(edge => {
          if (hideExternalEdges && isExternalEdge(edge)) {
            edge.style('display', 'none');
          } else {
            edge.style('display', 'element');
          }
        });

        // Show labels on connected nodes
        const connectedNodes = connectedEdges.connectedNodes();
        connectedNodes.forEach(n => {
          n.data('_hoverLabel', true);
          n.style('label', n.data('label') || n.data('shortLabel') || n.data('name'));
        });

        // Also show label on hovered node
        node.style('label', node.data('label') || node.data('shortLabel') || node.data('name'));
      });

      cy.on('mouseout', 'node', function(e) {
        if (edgeMode !== 'hover') return;
        const node = e.target;

        // Get nodes in scope
        const nodesInScope = node.isParent() ? node.descendants().add(node) : node;

        // Hide edges connected to nodes in scope (unless another hovered/selected)
        const connectedEdges = nodesInScope.connectedEdges();
        connectedEdges.style('display', 'none');

        // Hide labels on connected nodes (restore based on zoom mode)
        const connectedNodes = connectedEdges.connectedNodes();
        connectedNodes.forEach(n => {
          n.removeData('_hoverLabel');
          // Restore label based on current zoom mode
          if (currentZoomMode === ZOOM_MODE.OVERVIEW) {
            n.style('label', '');
          } else if (currentZoomMode === ZOOM_MODE.STRUCTURE) {
            n.style('label', n.data('shortLabel') || '');
          }
          // Detail mode keeps labels, so no change needed
        });

        // Restore hovered node label
        if (currentZoomMode === ZOOM_MODE.OVERVIEW) {
          node.style('label', '');
        } else if (currentZoomMode === ZOOM_MODE.STRUCTURE) {
          node.style('label', node.data('shortLabel') || '');
        }
      });

      // Semantic zoom event handler
      cy.on('zoom', function() {
        if (zoomDebounceTimer) clearTimeout(zoomDebounceTimer);

        zoomDebounceTimer = setTimeout(() => {
          const newMode = getZoomModeFromLevel(cy.zoom());
          if (newMode !== currentZoomMode) {
            previousZoomMode = currentZoomMode;
            currentZoomMode = newMode;
            console.log(`Zoom: ${previousZoomMode} -> ${currentZoomMode} (zoom level: ${cy.zoom().toFixed(2)})`);
            applyZoomModeStyles(currentZoomMode);
          }
        }, ZOOM_DEBOUNCE_MS);
      });

      // Apply initial zoom mode on first render
      cy.one('render', () => {
        currentZoomMode = getZoomModeFromLevel(cy.zoom());
        applyZoomModeStyles(currentZoomMode);
      });
    }

    function showNodeInfo(data) {
      document.getElementById('infoName').textContent = data.label;
      document.getElementById('infoKind').textContent = data.kind;
      document.getElementById('infoFile').textContent = data.file || 'N/A';
      document.getElementById('infoVisibility').textContent = data.visibility || 'unknown';

      const sigEl = document.getElementById('infoSignature');
      if (data.signature) {
        sigEl.textContent = data.signature;
        sigEl.style.display = 'block';
      } else {
        sigEl.style.display = 'none';
      }

      document.getElementById('nodeInfo').classList.add('visible');
    }

    async function loadView() {
      const viewType = document.getElementById('viewType').value;
      document.getElementById('stats').textContent = 'Loading...';

      try {
        const res = await fetch(`${API}/view`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ view: viewType })
        });
        allData = await res.json();

        // Generate synthetic edges if none exist
        if (allData.elements.edges.length === 0) {
          allData.elements.edges = generateSyntheticEdges(allData.elements.nodes);
        }

        updateLegend();
        updateFileList();
        renderGraph();

      } catch (err) {
        const errorMsg = `Cannot connect to view service at ${API}. ` +
          `Please ensure the server is running. ` +
          `If using a different port, add ?apiPort=XXXX to the URL.`;
        document.getElementById('stats').textContent = 'Error: ' + errorMsg;
        console.error(err);
        alert(errorMsg);
      }
    }

    // Load data from a fixture file (JSON or SLB bundle)
    async function loadFromFixture(fixturePath) {
      if (fixturePath === 'api') {
        // Use live API
        return loadView();
      }

      document.getElementById('stats').textContent = 'Loading fixture...';

      try {
        const res = await fetch(fixturePath);
        if (!res.ok) {
          throw new Error(`Failed to load ${fixturePath}: ${res.status}`);
        }
        const bundle = await res.json();

        // Convert bundle format to internal allData format
        allData = {
          elements: {
            nodes: bundle.nodes.map(n => ({
              data: {
                id: n.node_id,
                label: n.name,
                kind: n.kind,
                file: n.file,
                route: n.route,
                visibility: n.visibility,
                parent: n.parent,
                signature: n.signature
              }
            })),
            edges: (bundle.edges || []).map(e => ({
              data: {
                id: e.edge_id,
                source: e.src,
                target: e.dst,
                kind: e.kind,
                confidence: e.confidence
              }
            }))
          }
        };

        // Generate synthetic edges if none exist in bundle
        if (allData.elements.edges.length === 0) {
          allData.elements.edges = generateSyntheticEdges(allData.elements.nodes);
        }

        console.log(`Loaded fixture: ${fixturePath} - ${allData.elements.nodes.length} nodes, ${allData.elements.edges.length} edges`);

        updateLegend();
        updateFileList();
        renderGraph();

      } catch (err) {
        document.getElementById('stats').textContent = 'Error: ' + err.message;
        console.error('Failed to load fixture:', err);
        alert('Failed to load fixture: ' + err.message);
      }
    }

    function generateSyntheticEdges(nodes) {
      const edges = [];
      const nodeMap = new Map(); // id -> node data
      const routeMap = new Map(); // route -> node id

      // Build lookup maps
      nodes.forEach(n => {
        nodeMap.set(n.data.id, n.data);
        if (n.data.route) {
          routeMap.set(n.data.route, n.data.id);
        }
      });

      // Group nodes by file for file-level edges
      const fileNodes = new Map(); // file -> [node ids]
      nodes.forEach(n => {
        const file = n.data.file;
        if (file) {
          if (!fileNodes.has(file)) fileNodes.set(file, []);
          fileNodes.get(file).push(n.data);
        }
      });

      // For each file, find parent-child relationships based on route hierarchy
      fileNodes.forEach((fileNodeList, file) => {
        // Sort by route length (shorter = parent)
        const sorted = [...fileNodeList].filter(n => n.route).sort((a, b) =>
          (a.route || '').length - (b.route || '').length
        );

        // Create edges for class->method, module->function relationships
        const classes = sorted.filter(n => n.kind === 'class' || n.kind === 'interface');
        const functions = sorted.filter(n => n.kind === 'function');
        const methods = sorted.filter(n => n.kind === 'method');
        const modules = sorted.filter(n => n.kind === 'module');

        // Methods belong to classes (same file, method route contains class name)
        classes.forEach(cls => {
          if (!cls.name) return;
          methods.forEach(method => {
            // Check if method route contains class name pattern
            if (method.route && method.route.includes(cls.name)) {
              edges.push({
                data: {
                  id: `synth_${cls.id}_${method.id}`,
                  source: cls.id,
                  target: method.id,
                  kind: 'defines'
                }
              });
            }
          });
        });

        // Create co-location edges for classes in the same file
        if (classes.length > 1) {
          for (let i = 0; i < classes.length - 1; i++) {
            if (classes[i].id && classes[i+1].id) {
              edges.push({
                data: {
                  id: `synth_sibling_${classes[i].id}_${classes[i+1].id}`,
                  source: classes[i].id,
                  target: classes[i+1].id,
                  kind: 'sibling'
                }
              });
            }
          }
        }

        // Interface implementations - find classes that might implement interfaces
        const interfaces = sorted.filter(n => n.kind === 'interface');
        classes.forEach(cls => {
          if (!cls.name) return;
          interfaces.forEach(iface => {
            if (!iface.name) return;
            // Simple heuristic: class name contains interface name
            const clsBase = cls.name.replace('Impl', '');
            if (cls.name.includes(iface.name) || iface.name.includes(clsBase)) {
              edges.push({
                data: {
                  id: `synth_impl_${cls.id}_${iface.id}`,
                  source: cls.id,
                  target: iface.id,
                  kind: 'implements'
                }
              });
            }
          });
        });
      });

      // Cross-file relationships based on name matching (import-like)
      const allNodes = [...nodeMap.values()];
      const exportedNames = new Map(); // name -> [nodes]

      allNodes.forEach(n => {
        if (n.visibility === 'public' || n.kind === 'interface' || n.kind === 'class') {
          if (!exportedNames.has(n.name)) exportedNames.set(n.name, []);
          exportedNames.get(n.name).push(n);
        }
      });

      // Find cross-file references (functions that use class names, etc.)
      allNodes.forEach(n => {
        if (n.signature && typeof n.signature === 'string') {
          // Check if signature references known types
          exportedNames.forEach((targets, typeName) => {
            if (typeName && n.signature.includes(typeName)) {
              targets.forEach(target => {
                if (target && target.file !== n.file && target.id !== n.id) {
                  edges.push({
                    data: {
                      id: `synth_uses_${n.id}_${target.id}`,
                      source: n.id,
                      target: target.id,
                      kind: 'uses'
                    }
                  });
                }
              });
            }
          });
        }
      });

      console.log(`Generated ${edges.length} synthetic edges`);
      return edges;
    }

    function updateLegend() {
      if (!allData) return;

      // Count nodes by kind
      const counts = {};
      allData.elements.nodes.forEach(n => {
        const kind = n.data.kind;
        counts[kind] = (counts[kind] || 0) + 1;
      });

      const legend = document.getElementById('legend');
      legend.innerHTML = '';

      Object.entries(kindLabels).forEach(([kind, label]) => {
        if (!counts[kind]) return;

        const item = document.createElement('div');
        item.className = 'legend-item' + (enabledKinds.has(kind) ? '' : ' disabled');
        item.innerHTML = `
          <div class="legend-dot" style="background: ${kindColors[kind]}"></div>
          <span>${label}</span>
          <span class="legend-count">${counts[kind]}</span>
        `;
        item.onclick = () => toggleKind(kind);
        legend.appendChild(item);
      });
    }

    function toggleKind(kind) {
      if (enabledKinds.has(kind)) {
        enabledKinds.delete(kind);
      } else {
        enabledKinds.add(kind);
      }
      updateLegend();
      renderGraph();
    }

    function updateFileList() {
      if (!allData) return;

      // Get unique files
      const files = new Set();
      allData.elements.nodes.forEach(n => {
        if (n.data.file) files.add(n.data.file);
      });

      const fileList = document.getElementById('fileList');
      fileList.innerHTML = '';

      // Add "All files" option
      const allItem = document.createElement('div');
      allItem.className = 'file-item' + (!selectedFile ? ' selected' : '');
      allItem.textContent = `All files (${files.size})`;
      allItem.onclick = () => selectFile(null);
      fileList.appendChild(allItem);

      // Add each file
      [...files].sort().forEach(file => {
        const item = document.createElement('div');
        item.className = 'file-item' + (selectedFile === file ? ' selected' : '');
        item.textContent = file.split('/').pop(); // Just filename
        item.title = file;
        item.onclick = () => selectFile(file);
        fileList.appendChild(item);
      });
    }

    function selectFile(file) {
      selectedFile = file;
      updateFileList();
      renderGraph();
    }

    function renderGraph() {
      if (!allData) return;

      const layoutType = document.getElementById('layoutType').value;
      const searchTerm = document.getElementById('search').value.toLowerCase();

      // Filter nodes
      let filteredNodes = allData.elements.nodes.filter(n => {
        if (!enabledKinds.has(n.data.kind)) return false;
        if (selectedFile && n.data.file !== selectedFile) return false;
        if (searchTerm && !n.data.label.toLowerCase().includes(searchTerm)) return false;
        return true;
      });

      // Group by file for hierarchical layout
      const fileGroups = {};
      filteredNodes.forEach(n => {
        const file = n.data.file || 'unknown';
        if (!fileGroups[file]) fileGroups[file] = [];
        fileGroups[file].push(n);
      });

      // Build elements - support compound nodes via parent field
      const elements = { nodes: [], edges: [] };

      // Build node ID set for orphan detection
      const nodeIds = new Set(filteredNodes.map(n => n.data.id));

      // Track which parents we've seen
      const seenParents = new Set();
      const parentNodes = new Map(); // id -> node data

      // First pass: identify all parent nodes
      filteredNodes.forEach(n => {
        if (n.data.parent) {
          seenParents.add(n.data.parent);
        }
      });

      // Helper to create shortLabel for truncated display
      function makeShortLabel(label) {
        if (!label) return '';
        return label.length > 18 ? label.slice(0, 15) + '...' : label;
      }

      // Add nodes with parent relationships
      filteredNodes.forEach(n => {
        const hasParent = n.data.parent;
        const parentExists = hasParent && nodeIds.has(n.data.parent);

        // If node has parent reference but parent is missing, clear it to avoid Cytoscape errors
        if (hasParent && !parentExists) {
          console.warn(`Orphaned node ${n.data.id}: parent ${n.data.parent} not found in graph`);
          const { parent, ...nodeData } = n.data;
          elements.nodes.push({
            data: { ...nodeData, shortLabel: makeShortLabel(nodeData.label) },
            classes: 'code orphaned'
          });
        } else {
          // Keep parent property if parent exists
          elements.nodes.push({
            data: { ...n.data, shortLabel: makeShortLabel(n.data.label) },
            classes: 'code'
          });
        }

        // Track if this node is a parent (for potential parent node creation)
        if (seenParents.has(n.data.id)) {
          parentNodes.set(n.data.id, n.data);
        }
      });

      // Add edges if they reference visible nodes, with filtering
      const visibleNodeIds = new Set(elements.nodes.map(n => n.data.id));
      allData.elements.edges.forEach(e => {
        if (!visibleNodeIds.has(e.data.source) || !visibleNodeIds.has(e.data.target)) {
          return;  // Skip edges to/from invisible nodes
        }

        // Apply edge filtering
        const edgeKind = e.data.kind;
        if (edgeFilterMode === 'non-synthetic') {
          // Exclude synthetic edges (sibling = co-location)
          if (edgeKind === 'sibling') return;
        } else if (edgeFilterMode === 'structural') {
          // Only include structural edges (defines, inherits, implements)
          if (!['defines', 'inherits', 'implements'].includes(edgeKind)) return;
        }

        elements.edges.push({
          data: e.data,
          classes: e.data.kind ? '' : 'relationship'
        });
      });

      initCytoscape(elements);

      // Apply layout - get container dimensions for bounding box
      const container = document.getElementById('cy');
      const bb = {
        x1: 0,
        y1: 0,
        w: container.clientWidth,
        h: container.clientHeight
      };

      let layoutConfig;
      switch (layoutType) {
        case 'elk':
          // ELK server-side layout
          document.getElementById('stats').textContent = 'Computing ELK layout...';
          runElkLayout(cy).then(() => {
            // Update stats after ELK completes
            const visibleNodes = cy.nodes(':visible').length;
            const visibleEdges = cy.edges(':visible').length;
            document.getElementById('stats').textContent =
              `${visibleNodes} nodes | ${visibleEdges} edges | ELK layout`;
            updateEdgeLegend();
            updateGraphStats(cy);
          });
          return;  // Skip normal layout flow

        case 'community':
          // Community detection layout with circular arrangement
          layoutParams = getLayoutParams();
          clearLensCache();  // Reset caches when graph changes

          const result = communityLayout();

          // Mark nodes and apply coloring
          markSuspiciousNodes();
          if (colorByConnectivityEnabled) {
            colorByConnectivity();
          }

          // Apply current lens if not default
          if (currentLens !== 'default') {
            applyLens(currentLens);
          }

          // Apply level-of-detail (hide methods by default)
          applyLevelOfDetail();

          // Update stats
          const connectedCount = cy.nodes('.code').filter(n => n.degree() > 0).length;
          document.getElementById('stats').textContent =
            `${connectedCount} connected (${result?.numCommunities || 0} communities) | ${result?.isolated || 0} isolated`;
          updateEdgeLegend();
          updateGraphStats(cy);
          return;  // Skip normal layout flow

        case 'cola':
          layoutConfig = {
            name: 'cola',
            nodeSpacing: 20,
            edgeLength: 50,
            animate: false,
            boundingBox: bb,
            fit: true,
            padding: 30,
            convergenceThreshold: 0.01,
            maxSimulationTime: 4000
          };
          break;
        case 'circle':
          // Update layout params for current viewport
          layoutParams = getLayoutParams();

          // Sub-circle layout: group connected nodes by file into sub-circles
          const connectedNodes = cy.nodes('.code').filter(n => n.degree() > 0);
          const isolatedNodes = cy.nodes('.code').filter(n => n.degree() === 0);

          // Mark isolated nodes with class for styling
          isolatedNodes.addClass('isolated');
          connectedNodes.removeClass('isolated');

          // Apply sub-circle layout
          layoutSubCircles();

          // Mark nodes and apply coloring
          markSuspiciousNodes();
          if (colorByConnectivityEnabled) {
            colorByConnectivity();
          }

          // Apply level-of-detail (hide methods by default)
          applyLevelOfDetail();

          // Update stats for circle layout
          const fileCount = Object.keys(getFileGroups()).length;
          document.getElementById('stats').textContent =
            `${connectedNodes.length} connected (${fileCount} groups) | ${isolatedNodes.length} isolated`;
          updateEdgeLegend();
          updateGraphStats(cy);
          return;  // Skip normal layout flow
        case 'grid':
          layoutConfig = { name: 'grid', animate: false, boundingBox: bb, rows: Math.ceil(Math.sqrt(elements.nodes.length)), padding: 50 };
          break;
        case 'hierarchy':
        default:
          // fCoSE layout - better node distribution than COSE
          layoutConfig = {
            name: 'fcose',
            animate: false,
            boundingBox: bb,
            fit: true,
            quality: 'proof',
            nodeRepulsion: 4500,
            idealEdgeLength: 100,
            gravity: 0.25,
            gravityRange: 3.8,
            nodeSeparation: 75,
            tilingPaddingVertical: 20,
            tilingPaddingHorizontal: 20,
            padding: 50
          };
      }

      // Run layout and fit after completion
      const layout = cy.layout(layoutConfig);
      layout.one('layoutstop', () => {
        if (autoFitEnabled) {
          cy.fit(undefined, 50);
        }
        // Mark suspicious/orphaned nodes for data quality visualization
        markSuspiciousNodes();
        // Apply connectivity coloring if enabled
        if (colorByConnectivityEnabled) {
          colorByConnectivity();
        }
        // Apply level-of-detail (hide methods by default)
        applyLevelOfDetail();
      });
      layout.run();

      // Update stats
      const visibleNodes = cy.nodes('.code').length;
      const visibleEdges = cy.edges().length;
      document.getElementById('stats').textContent =
        `${visibleNodes} nodes | ${visibleEdges} edges | ${Object.keys(fileGroups).length} files`;

      // Update edge legend counts
      updateEdgeLegend();

      // Update graph stats (connected/isolates)
      updateGraphStats(cy);
    }

    function updateEdgeLegend() {
      if (!allData) return;

      const edgeCounts = { defines: 0, implements: 0, uses: 0, sibling: 0 };
      allData.elements.edges.forEach(e => {
        const kind = e.data.kind;
        if (kind && edgeCounts[kind] !== undefined) {
          edgeCounts[kind]++;
        }
      });

      document.getElementById('edgeDefines').textContent = edgeCounts.defines;
      document.getElementById('edgeImplements').textContent = edgeCounts.implements;
      document.getElementById('edgeUses').textContent = edgeCounts.uses;
      document.getElementById('edgeSibling').textContent = edgeCounts.sibling;
    }

    function expandAll() {
      cy.nodes('.file').forEach(n => n.style('display', 'element'));
    }

    function collapseAll() {
      // Not implemented yet - would need compound node collapse
    }

    // Show full graph - return from zoomed view
    function showFullGraph() {
      if (!cy) return;
      isZoomedIn = false;
      document.getElementById('backBtn').style.display = 'none';
      cy.nodes().show();
      cy.edges().show();
      renderGraph();
    }

    // Zoom into a node and its neighbors
    function zoomIntoNode(node) {
      isZoomedIn = true;
      document.getElementById('backBtn').style.display = 'inline-block';

      const neighbors = node.neighborhood().nodes();
      const relevantNodes = neighbors.union(node);
      const relevantEdges = node.connectedEdges();

      // Hide non-relevant elements
      cy.nodes().not(relevantNodes).hide();
      cy.edges().not(relevantEdges).hide();

      // Arrange relevant nodes in circle
      relevantNodes.layout({
        name: 'circle',
        fit: true,
        padding: 80,
        animate: true,
        animationDuration: 400
      }).run();

      // Show all labels in zoomed view
      relevantNodes.style('label', (ele) => ele.data('label'));
    }

    // Search handler with debounce
    let searchTimeout;
    document.getElementById('search').addEventListener('input', () => {
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(renderGraph, 300);
    });

    // Layout change handler
    document.getElementById('layoutType').addEventListener('change', renderGraph);

    // View type change handler
    document.getElementById('viewType').addEventListener('change', loadView);

    // Auto-fit toggle handler
    document.getElementById('autoFitToggle').addEventListener('click', function() {
      autoFitEnabled = !autoFitEnabled;
      this.classList.toggle('active', autoFitEnabled);
      this.textContent = autoFitEnabled ? '[ON] Auto-Fit' : '[OFF] Locked';
      this.title = autoFitEnabled ? 'Auto-Fit: ON - Click to lock view' : 'View Locked - Click to enable auto-fit';

      if (autoFitEnabled && cy) {
        cy.fit(undefined, 50);
      }
    });

    // Fit button handler - also enables auto-fit
    document.getElementById('fitBtn').addEventListener('click', () => {
      if (cy) {
        cy.fit(undefined, 50);
        // Also enable auto-fit when user explicitly clicks Fit
        autoFitEnabled = true;
        const toggle = document.getElementById('autoFitToggle');
        toggle.classList.add('active');
        toggle.textContent = '[ON] Auto-Fit';
        toggle.title = 'Auto-Fit: ON - Click to lock view';
      }
    });

    // Connectivity coloring toggle
    document.getElementById('connectivityToggle').addEventListener('click', function() {
      colorByConnectivityEnabled = !colorByConnectivityEnabled;
      this.classList.toggle('active', colorByConnectivityEnabled);
      this.textContent = colorByConnectivityEnabled ? 'Color by Degree [ON]' : 'Color by Degree';

      if (colorByConnectivityEnabled) {
        colorByConnectivity();
      } else {
        resetNodeColors();
      }
    });

    // Lens selector change handler
    document.getElementById('lensType').addEventListener('change', function() {
      applyLens(this.value);
    });

    // Show Methods toggle handler
    document.getElementById('showMethods').addEventListener('change', function() {
      showMethodsEnabled = this.checked;
      applyLevelOfDetail();
    });

    // Edge filter change handler
    document.getElementById('edgeFilter').addEventListener('change', function() {
      edgeFilterMode = this.value;
      renderGraph();  // Re-render with new edge filter
    });

    // Isolate ring toggle handler
    document.getElementById('showIsolateRing').addEventListener('change', function() {
      showIsolateRing = this.checked;
      if (cy) {
        layoutIsolateRing(cy);
        fitGraph(cy);
      }
    });

    // Fit to connected toggle handler
    document.getElementById('fitToConnected').addEventListener('change', function() {
      fitToConnectedOnly = this.checked;
      if (cy) {
        fitGraph(cy);
      }
    });

    // External edges toggle handler
    document.getElementById('hideExternalEdges').addEventListener('change', function() {
      hideExternalEdges = this.checked;
      if (cy) {
        applyEdgeMode(cy);
      }
    });

    // Edge mode change handler
    document.getElementById('edgeMode').addEventListener('change', function() {
      edgeMode = this.value;
      if (cy) {
        applyEdgeMode(cy);
      }
    });

    // Window resize handler - recalculate sizes and re-layout
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        if (!cy) return;
        layoutParams = getLayoutParams();
        updateNodeStyles();

        // Re-layout if in circle mode
        const layoutType = document.getElementById('layoutType').value;
        if (layoutType === 'circle' && !isZoomedIn) {
          layoutSubCircles();
          markSuspiciousNodes();
          if (colorByConnectivityEnabled) {
            colorByConnectivity();
          }
        } else if (autoFitEnabled) {
          cy.fit(undefined, 50);
        }
      }, 250);
    });

    // Fixture selection handler
    document.getElementById('fixtureSelect').addEventListener('change', function() {
      loadFromFixture(this.value);
    });

    // Load initial view - use the default selected fixture
    const initialFixture = document.getElementById('fixtureSelect').value;
    if (initialFixture && initialFixture !== 'api') {
      loadFromFixture(initialFixture);
    } else {
      loadView();
    }
  </script>
</body>
</html>
